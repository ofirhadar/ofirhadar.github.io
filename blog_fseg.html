<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unsupervised Semantic Segmentation with F-Seg</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            line-height: 1.6;
        }
        .nav-bar {
            background-color: #333;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            text-align: center;
        }
        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 15px 25px;
            font-size: 1.1em;
        }
        .nav-bar a:hover {
            background-color: #555;
        }
        .container {
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1, h2, h3 {
            color: #333;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        h2 {
            margin-top: 40px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        h3 {
            margin-top: 25px;
        }
        .math {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', monospace;
        }
        p {
            margin-bottom: 20px;
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="nav-bar">
        <a href="index.html">About Me</a>
        <a href="publications.html">Publications</a>
        <a href="patents.html">Patents</a>
        <a href="blogs.html">Blog</a>
    </div>
    <div class="container">
        <h1>Unsupervised Semantic Segmentation with F-Seg</h1>

        <img src="images/fseg_pipeline.png" alt="F-Seg Pipeline" style="width: 80%; height: auto; display: block; margin: 0 auto;">

        <p>Unsupervised segmentation in digital pathology is a challenging problem. The F-Seg method leverages deep feature factorization (DFF) to extract meaningful concepts from image activations, enabling segmentation without labeled data. In this post, we explore the theoretical foundations of F-Seg, supported by mathematical formulations and practical Python code.</p>

        <h2>Deep Feature Factorization (DFF) and Non-Negative Matrix Factorization (NMF)</h2>

        <h3>Theoretical Background</h3>

        <p>Given an input image \( I \), a deep network extracts activation maps \( A \in \mathbb{R}^{C \times H \times W} \), where \( C \) is the number of feature channels, and \( H \times W \) is the spatial resolution. Our goal is to decompose these activations into a set of interpretable components.</p>

        <p>DFF achieves this via Non-Negative Matrix Factorization (NMF). The activation tensor is reshaped into a matrix \( A \in \mathbb{R}^{C \times (H \cdot W)} \), and we seek a factorization:</p>

        <p>\[ A \approx W H \]</p>

        <p>where:</p>
        <ul>
            <li>\( W \in \mathbb{R}^{C \times K} \) represents the concept basis (semantic components), and</li>
            <li>\( H \in \mathbb{R}^{K \times (H \cdot W)} \) represents the concept activations per spatial location.</li>
        </ul>

        <p>The optimization problem solved by NMF is:</p>

        <p>\[ \min_{W, H} \| A - W H \|_F^2 \quad \text{subject to} \quad W \geq 0, H \geq 0 \]</p>

        <p>where \( \| \cdot \|_F \) denotes the Frobenius norm.</p>

        <h3>Why Non-Negative Matrix Factorization (NMF)?</h3>

        <p>NMF is particularly well-suited for unsupervised segmentation because it ensures that both the basis components and the activations are non-negative. This leads to parts-based representations, which aligns well with the idea of decomposing an image into meaningful segments. Unlike SVD, which allows both positive and negative values, NMF produces interpretable components that resemble actual object parts. Furthermore, compared to other matrix factorization techniques like ICA or SVD, NMF is more robust in extracting localized features, which is crucial in image segmentation tasks where spatial coherence is important.</p>

        <h3>Implementation</h3>

        <pre><code>import numpy as np
import torch
from sklearn.decomposition import NMF

# Perform Deep Feature Factorization using NMF
def dff(activations: np.ndarray, n_components: int = 5):
    batch_size, __, h, w = activations.shape
    reshaped_activations = activations.transpose((1, 0, 2, 3)).reshape(activations.shape[1], -1)
    reshaped_activations[np.isnan(reshaped_activations)] = 0
    model = NMF(n_components=n_components, init='random', random_state=0)
    W = model.fit_transform(reshaped_activations)
    H = model.components_.reshape(n_components, batch_size, h, w)
    return W, H.transpose((1, 0, 2, 3))</code></pre>

        <h2>Example Input and Output</h2>
        <p>Below is an example of an input image and the corresponding segmentation mask generated using DFF:</p>
            
        <img src="images/fseg_grayscale_example.png" alt="DFF Segmentation Example" style="width: 50%; height: auto;">

        <h2>Visualizing Segmentation</h2>

        <p>After factorization, we assign each pixel to the dominant factor, creating a segmentation mask. The following function overlays the segmentation results on the input image.</p>

        <pre><code>import matplotlib.pyplot as plt

def show_segmentation_on_image(img: np.uint8, segmentation: np.ndarray, colors=None, image_weight=0.5):
    float_img = np.float32(img) / 255
    n_categories = np.max(segmentation) + 1
    if colors is None:
        cmap = plt.cm.get_cmap('gist_rainbow')
        colors = [np.array(cmap(i)[:3]) for i in np.linspace(0, 1, n_categories)]
    mask = np.zeros_like(float_img)
    for category in range(n_categories):
        mask[segmentation == category] = colors[category]
    return np.uint8((float_img * image_weight + mask * (1 - image_weight)) * 255)</code></pre>

        <h2>F-Seg: From Factorization to Segmentation</h2>

        <p>F-Seg leverages DFF for unsupervised segmentation. The extracted semantic concepts guide the clustering of image regions.</p>

        <h3>Clustering Concepts</h3>

        <p>Once we obtain the matrix \( W \), we cluster the feature vectors into distinct semantic groups. Given a set of cluster centroids \( C \), each feature vector \( w_i \) is assigned to the nearest cluster using cosine similarity:</p>

        <p>\[ \text{Label}(w_i) = \arg\min_j \frac{w_i \cdot C_j}{\|w_i\| \|C_j\|} \]</p>

        <h3>Applying F-Seg</h3>

        <pre><code>class FSeg:
    def __init__(self, model, target_layer, reshape_transform=None):
        self.model = model
        self.target_layer = target_layer
        self.reshape_transform = reshape_transform
        self.activations_and_grads = ActivationsAndGradients(self.model, [self.target_layer], self.reshape_transform)
    
    def get_activations(self, input_tensor: torch.tensor) -> np.ndarray:
        with torch.no_grad():
            self.activations_and_grads(input_tensor)
            return self.activations_and_grads.activations[0].cpu().numpy()
    
    def predict_on_single_image(self, input_tensor: torch.tensor, k: int):
        activations = self.get_activations(input_tensor)
        _, w = dff(activations, k)
        segmentation = np.argmax(w[0], axis=0)
        return segmentation</code></pre>

        <h2>Conclusion</h2>

        <p>F-Seg enables unsupervised segmentation by leveraging feature factorization. The method decomposes high-dimensional feature spaces into semantic components, making it useful for pathology and other domains where labeled data is scarce. Experiment with different values of \( k \) to observe its effect on segmentation granularity!</p>
    </div>
</body>
</html>
